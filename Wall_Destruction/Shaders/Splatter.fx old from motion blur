#include "GlobalParameters.inc"

struct VS_INPUT{
	float4 center : position;
	float4 U : normal0; // tangent
	float4 V : normal1; // other tangent
	float4 N : normal2;
};

struct GS_INPUT{
	float4 center : position;
	float4 velocity : position1; // just because the motion blur for ewa has this...
	float4 U : normal0;
	float4 V : normal1;
	float4 N : normal2;
};

struct PS_INPUT{

};

struct PS_OUTPUT{

};

GS_INPUT SplatterVS(VS_INPUT vsin){
	GS_INPUT gsin = (GS_INPUT) 0;
	
	gsin.center = vsin.center;
	gsin.U = vsin.U;
	gsin.V = vsin.V;
	gsin.N = vsin.N;
	gsin.velocity = float4(0.0f, 0.0f, 0.0f, 0.0f);
	
	// 3D spatio-temporal reconstruction kernel	
	float4x4 T = float4x4(vsin.U.x, vsin.V.x, 0.0f, -vsin.center.x, 
						  vsin.U.y, vsin.V.y, 0.0f, -vsin.center.y, 
						  vsin.U.z, vsin.V.z, 0.0f, -vsin.center.z, 
						  0.0f    , 0.0f    , 0.0f, 1.0f);
				
	// Q = invTrans(T) * inv(T)		  
	float4x4 invT = GetInverse(T);
	float4x4 Q = transpose(invT) * invT;
	
	float gaussianVariance = 1.0f;
	float gaussianKernel = rsqrt(pow(guassianVariance, 3) * determinant(Q) / pow(3.14f, 3)) * exp(-gaussianVariance * transpose(
	 
	
	
	
	return gsin;
}

// method created from information found at http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
float4x4 GetInverse(float4x4 m){
	float4x4 outMat;
	outMat(0, 0) = m(1, 2)*m(2, 3)*m(3, 1) - m(1, 3)*m(2, 2)*m(3, 1) + m(1, 3)*m(2, 1)*m(3, 2) - m(1, 1)*m(2, 3)*m(3, 2) - m(1, 2)*m(2, 1)*m(3, 3) + m(1, 1)*m(2, 2)*m(3, 3);
	outMat(0, 1) = m(0, 3)*m(2, 2)*m(3, 1) - m(0, 2)*m(2, 3)*m(3, 1) - m(0, 3)*m(2, 1)*m(3, 2) + m(0, 1)*m(2, 3)*m(3, 2) + m(0, 2)*m(2, 1)*m(3, 3) - m(0, 1)*m(2, 2)*m(3, 3);
	outMat(0, 2) = m(0, 2)*m(1, 3)*m(3, 1) - m(0, 3)*m(1, 2)*m(3, 1) + m(0, 3)*m(1, 1)*m(3, 2) - m(0, 1)*m(1, 3)*m(3, 2) - m(0, 2)*m(1, 1)*m(3, 3) + m(0, 1)*m(1, 2)*m(3, 3);
	outMat(0, 3) = m(0, 3)*m(1, 2)*m(2, 1) - m(0, 2)*m(1, 3)*m(2, 1) - m(0, 3)*m(1, 1)*m(2, 2) + m(0, 1)*m(1, 3)*m(2, 2) + m(0, 2)*m(1, 1)*m(2, 3) - m(0, 1)*m(1, 2)*m(2, 3);
	outMat(1, 0) = m(1, 3)*m(2, 2)*m(3, 0) - m(1, 2)*m(2, 3)*m(3, 0) - m(1, 3)*m(2, 0)*m(3, 2) + m(1, 0)*m(2, 3)*m(3, 2) + m(1, 2)*m(2, 0)*m(3, 3) - m(1, 0)*m(2, 2)*m(3, 3);
	outMat(1, 1) = m(0, 2)*m(2, 3)*m(3, 0) - m(0, 3)*m(2, 2)*m(3, 0) + m(0, 3)*m(2, 0)*m(3, 2) - m(0, 0)*m(2, 3)*m(3, 2) - m(0, 2)*m(2, 0)*m(3, 3) + m(0, 0)*m(2, 2)*m(3, 3);
	outMat(1, 2) = m(0, 3)*m(1, 2)*m(3, 0) - m(0, 2)*m(1, 3)*m(3, 0) - m(0, 3)*m(1, 0)*m(3, 2) + m(0, 0)*m(1, 3)*m(3, 2) + m(0, 2)*m(1, 0)*m(3, 3) - m(0, 0)*m(1, 2)*m(3, 3);
	outMat(1, 3) = m(0, 2)*m(1, 3)*m(2, 0) - m(0, 3)*m(1, 2)*m(2, 0) + m(0, 3)*m(1, 0)*m(2, 2) - m(0, 0)*m(1, 3)*m(2, 2) - m(0, 2)*m(1, 0)*m(2, 3) + m(0, 0)*m(1, 2)*m(2, 3);
	outMat(2, 0) = m(1, 1)*m(2, 3)*m(3, 0) - m(1, 3)*m(2, 1)*m(3, 0) + m(1, 3)*m(2, 0)*m(3, 1) - m(1, 0)*m(2, 3)*m(3, 1) - m(1, 1)*m(2, 0)*m(3, 3) + m(1, 0)*m(2, 1)*m(3, 3);
	outMat(2, 1) = m(0, 3)*m(2, 1)*m(3, 0) - m(0, 1)*m(2, 3)*m(3, 0) - m(0, 3)*m(2, 0)*m(3, 1) + m(0, 0)*m(2, 3)*m(3, 1) + m(0, 1)*m(2, 0)*m(3, 3) - m(0, 0)*m(2, 1)*m(3, 3);
	outMat(2, 2) = m(0, 1)*m(1, 3)*m(3, 0) - m(0, 3)*m(1, 1)*m(3, 0) + m(0, 3)*m(1, 0)*m(3, 1) - m(0, 0)*m(1, 3)*m(3, 1) - m(0, 1)*m(1, 0)*m(3, 3) + m(0, 0)*m(1, 1)*m(3, 3);
	outMat(2, 3) = m(0, 3)*m(1, 1)*m(2, 0) - m(0, 1)*m(1, 3)*m(2, 0) - m(0, 3)*m(1, 0)*m(2, 1) + m(0, 0)*m(1, 3)*m(2, 1) + m(0, 1)*m(1, 0)*m(2, 3) - m(0, 0)*m(1, 1)*m(2, 3);
	outMat(3, 0) = m(1, 2)*m(2, 1)*m(3, 0) - m(1, 1)*m(2, 2)*m(3, 0) - m(1, 2)*m(2, 0)*m(3, 1) + m(1, 0)*m(2, 2)*m(3, 1) + m(1, 1)*m(2, 0)*m(3, 2) - m(1, 0)*m(2, 1)*m(3, 2);
	outMat(3, 1) = m(0, 1)*m(2, 2)*m(3, 0) - m(0, 2)*m(2, 1)*m(3, 0) + m(0, 2)*m(2, 0)*m(3, 1) - m(0, 0)*m(2, 2)*m(3, 1) - m(0, 1)*m(2, 0)*m(3, 2) + m(0, 0)*m(2, 1)*m(3, 2);
	outMat(3, 2) = m(0, 2)*m(1, 1)*m(3, 0) - m(0, 1)*m(1, 2)*m(3, 0) - m(0, 2)*m(1, 0)*m(3, 1) + m(0, 0)*m(1, 2)*m(3, 1) + m(0, 1)*m(1, 0)*m(3, 2) - m(0, 0)*m(1, 1)*m(3, 2);
	outMat(3, 3) = m(0, 1)*m(1, 2)*m(2, 0) - m(0, 2)*m(1, 1)*m(2, 0) + m(0, 2)*m(1, 0)*m(2, 1) - m(0, 0)*m(1, 2)*m(2, 1) - m(0, 1)*m(1, 0)*m(2, 2) + m(0, 0)*m(1, 1)*m(2, 2);
	outMat *= rcp(determinant(m));
}

[maxvertexcount(4)]
void SplatterGS(point GS_INPUT gsin[1], inout TriangleStream<PS_SURFEL_INPUT> splatStream)
{

}

PS_OUTPUT SplatterPS(PS_INPUT psin){

}


technique10 SplatterTechnique
{
    pass P0
    {
        SetVertexShader( CompileShader( vs_4_0, SplatterVS() ) );
	    SetGeometryShader( CompileShader(gs_4_0, SplatterGS()));
        SetPixelShader( CompileShader( ps_4_0, SplatterPS() ) );
		
		SetDepthStencilState( EnableDepth, 0 );
		SetRasterizerState(SOLID);
 	    SetBlendState( NoAlphaBlending, float4( 0.0f, 0.0f, 0.0f, 0.0f ), 0xFFFFFFFF );
    }
}