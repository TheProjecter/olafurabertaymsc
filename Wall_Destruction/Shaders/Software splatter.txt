1 // parameters
2 float F; // the size of the reconstruction filter, usually 2.0f
89
Implementation
3 float conditionThreshold; // ill-conditioning threshold, usually 100.0f
4 float prefiltersize; // the size of the prefilter, usually 1.0f
5 float focus; // the distance of the focal plane
6 float aperture; // the aperture of the lens, default value is 2.8f
7 float imagePlane = 1.0f; // fixed, do not change
8 int subpixels; // the number of sampler per pixel
9
10 Matrix4 objectToScreen; // mapping from object-space to screen-space
11 Vector2 vpScale; // the scaling factor from homogenous screen-space to the viewport
12 Vector2 vpMid; // the coordinates of the viewport origin
13 int scissorxmin,scissorxmax,scissorymin,scissorymax;
14
15 int clipPlanes = 6;
16 Vector4 clipOrigin[clipPlanes],clipNormal[clipPlanes];
17
18 int exptablesize; // 256 works well
19 float exptable[exptablesize]; // exp(-0.5f * F * float(index)/float(exptablesize))
20
21 // a set of poisson distributed samples locations
22 int jitterPatterns; // 64 distributions are usually enough
23 Vector2 prefilterJitter[jitterPatterns * subpixels];
24 Vector2 lensJitter[jitterPatterns * subpixels];
25
26 // a 2D array of randomly selected indices to distributions
27 int selSize; // 32 patterns are usually enough
28 int prefilterSelection[selSize * selSize];
29 int doffilterSelection[selSize * selSize];
30
31 // constants
32 float focalLength = imagePlane*focus/(imagePlane+focus);
33 float lensRadius = focalLength*0.5f/aperture;
34 float exptablescale = float(exptablesize)/F;
35
36 Vector2 oovpScale(1.0f/vpScale.x, 1.0f/vpScale.y);
37
38 Matrix2 Vp( prefiltersize*oovpScale.x*oovpScale.x, 0,
39 0, prefiltersize*oovpScale.y*oovpScale.y );
40 Matrix4 screenToObject = Invert(objectToScreen);
41 Vector4 c = screenToObject.z;
42 if( c.w != 0.0f ) c *= 1.0f/c.w;
43 else c = -c;
44
45 for(int i=0;i<numberOfSplats;++i) {
46 Vector3 p0 = splats[i].position;
47 Vector3 n = splats[i].normal;
48
49 // back-face cull (in object-space)
50 Vector4 pleq(n.x, n.y, n.z, -Dot(p0,n));
51 int dotSign = extractSign( Dot(c, pleq) );
52 if( dotSign ) continue; // negative = back-facing
53
54 // set up the conic matrix
55 Matrix2 Vr( splats[i].size, 0,
56 0, splats[i].size );
57 Matrix2 Q = Invert(Vr * Transpose(Vr));
58
59 // make the tangent plane (in object-space)
60 Vector3 tu = Normalize( Perpendicular( n ) );
61 Vector3 tv = Cross(n, tu);
62
63 // transform the tangents and the splat center to screen-space
64 Vector4 tuh(tu.x, tu.y, tu.z, 0);
65 Vector4 tvh(tv.x, tv.y, tv.z, 0);
66 Vector4 p0h(p0.x, p0.y, p0.z, 1);
67 tuh *= objectToScreen;
68 tvh *= objectToScreen;
69 p0h *= objectToScreen;
70
71 // view frustum culling
72 for(int cp=0;cp<clipPlanes;cp++) {
73 float a = Dot(tuh, clipNormal[cp]);
74 float b = Dot(tvh, clipNormal[cp]);
75 float c = Dot(p0h, clipNormal[cp]) - Dot(clipNormal[cp], clipOrigin[cp]);
76 if( a == 0.0f && b == 0.0f ) { // the planes are parallel
77 if( c < 0.0f ) break; // behind the clip plane
78 } else { // if behind the plane, discard
79 if( c < 0.0f &&
90
A.2 Splatting Pipeline Using Stochastic Sampling
80 F * (Q[0][0]*b*b - 2.0f*Q[0][1]*a*b + Q[1][1]*a*a) - c*c*Det(Q) < 0.0f )
81 break;
82 }
83 }
84 if( cp < clipPlanes ) continue; // the splat was behind some of the planes
85
86 // mapping from the splat to screen-space
87 Matrix3 M(tuh.x, tuh.y, tuh.w,
88 tvh.x, tvh.y, tvh.w,
89 p0h.x, p0h.y, p0h.w);
90 float detM = Det(M);
91
92 // mapping from screen-space to the splat
93 Matrix3 Mi( M[1][1]*M[2][2] - M[2][1]*M[1][2],
94 M[2][1]*M[0][2] - M[0][1]*M[2][2],
95 M[0][1]*M[1][2] - M[1][1]*M[0][2],
96 M[2][0]*M[1][2] - M[1][0]*M[2][2],
97 M[0][0]*M[2][2] - M[2][0]*M[0][2],
98 M[1][0]*M[0][2] - M[0][0]*M[1][2],
99 M[1][0]*M[2][1] - M[2][0]*M[1][1],
100 M[2][0]*M[0][1] - M[0][0]*M[2][1],
101 M[0][0]*M[1][1] - M[1][0]*M[0][1]); // inverse of M * Det(M)
102
103 Matrix3 Qh( Q[0][0], Q[0][1], 0,
104 Q[1][0], Q[1][1], 0,
105 0, 0, -F );
106 Matrix3 Qhs = Mi * Qh * Transpose(Mi);
107
108 // the bounding rectangle
109 float xmin = -1, xmax = 1;
110 float ymin = -1, ymax = 1;
111 float delta = Qhs[0][0] * Qhs[1][1] - Qhs[0][1] * Qhs[1][0];
112 if( delta > 0.0f ) { // ellipses can be bound, others must test the whole screen
113 float oodelta = 1.0f/delta;
114 float xt = (Qhs[0][1] * Qhs[1][2] - Qhs[1][1] * Qhs[0][2]) * oodelta;
115 float yt = (Qhs[0][1] * Qhs[0][2] - Qhs[0][0] * Qhs[1][2]) * oodelta;
116 float f = -Qhs[2][2] - xt * Qhs[0][2] - yt * Qhs[1][2];
117
118 float bx = sqrt(Qhs[1][1] * f * oodelta);
119 float by = sqrt(Qhs[0][0] * f * oodelta);
120
121 xmin = xt - bx;
122 xmax = xt + bx;
123 ymin = yt - by;
124 ymax = yt + by;
125 }
126
127 // calculate zmin and zmax
128 float zmin = p0h.w,zmax = p0h.w;
129 float l = Q[0][0]*tuh.w*tuh.w + 2.0f*Q[0][1]*tuh.w*tvh.w + Q[1][1]*tvh.w*tvh.w;
130 if( l != 0.0f ) {
131 l = sqrt(MAX(0.0f,F/l));
132 zmin = p0h.w - l * (tuh.w*tuh.w + tvh.w*tvh.w);
133 zmax = p0h.w + l * (tuh.w*tuh.w + tvh.w*tvh.w);
134 }
135
136 // calculate the radius of the circle of confusion for DOF
137 float focusDistZMin = focalLength * zmin / (zmin - focalLength);
138 float focusDistZMax = focalLength * zmax / (zmax - focalLength);
139 float cocZMin = fabs(focusDistZMin - imagePlane)*focalLength/(aperture*focusDistZMin);
140 float cocZMax = fabs(focusDistZMax - imagePlane)*focalLength/(aperture*focusDistZMax);
141 float coc = 0.5f * MAX(cocZMin,cocZMax);
142
143 // determine the integer bounding rectangle and do scissoring
144 xmin = (xmin - coc) * vpScale.x + vpMid.x - prefiltersize;
145 xmax = (xmax + coc) * vpScale.x + vpMid.x + prefiltersize;
146 ymin = (ymin - coc) * vpScale.y + vpMid.y - prefiltersize;
147 ymax = (ymax + coc) * vpScale.y + vpMid.y + prefiltersize;
148
149 int sx = floor( xmin ), ex = ceil( xmax );
150 if( sx >= width || ex <= 0 ) continue;
151 sx = MAX(sx,scissorxmin);
152 ex = MIN(ex,scissorxmax);
153 if( ex - sx == 0 ) continue;
154
155 int sy = floor( ymin ), ey = ceil( ymax );
156 if( sy >= height || ey <= 0 ) continue;
91
Implementation
157 sy = MAX(sy,scissorymin);
158 ey = MIN(ey,scissorymax);
159 if( ey - sy == 0 ) continue;
160
161 Vector4 color(0,0,0,1); // rgba
162 // call the splat shader here
163
164 // rasterization loop
165 ABuffer::Fragment fragment;
166 fragment.color = color;
167 fragment.zmin = zmin;
168 fragment.zmax = zmax;
169 fragment.dotSign = dotSign;
170 for(int y=sy;y<ey;++y)
171 for(int x=sx;x<ex;++x) {
172 int aapattern = prefilterSelection[(y&(selSize-1))*selSize+(x&(selSize-1))];
173 int dofpattern = doffilterSelection[(y&(selSize-1))*selSize+(x&(selSize-1))];
174 Vector2 sp(((float)x - vpMid.x) * oovpScale.x,
175 ((float)y - vpMid.y) * oovpScale.y);
176 for(int j=0;j<subpixels;j++) {
177 // jittered sample location around the pixel
178 Vector3 f(sp.x + prefilterJitter[aapattern+j].x*oovpScale.x,
179 sp.y + prefilterJitter[aapattern+j].y*oovpScale.y, 1);
180 f *= focus; // the focal point
181 Vector3 p(lensJitter[dofpattern+j].x,
182 lensJitter[dofpattern+j].y, 0);// a point on the lens
183 f -= p;
184 f *= Mi;
185 p *= Mi;
186 Vector3 uv(detM*f.x - f.x*p.z + f.z*p.x,
187 detM*f.y - f.y*p.z + f.z*p.y,
188 detM*f.z); // homogenous point on the splat plane
189
190 float radius = Q[0][0]*uv.x*uv.x + 2.0f*Q[0][1]*uv.x*uv.y + Q[1][1]*uv.y*uv.y;
191 if( radius < F*uv.z*uv.z ) {
192 float ooh = 1.0f / uv.z;
193 float z = p0h.z + uv.x * ooh * tuh.z + uv.y * ooh * tvh.z;
194 if( z > 0.0f ) {
195 radius *= ooh * ooh * exptablescale;
196 fragment.weight = exptable[MAX(0,(int)floor(radius))];
197 fragment.z = z; // needed, if the surface reconstruction uses z
198 abuffer->appendFragment(x,y,j,fragment);
199 }
200 }
201 }
202 }
203 }