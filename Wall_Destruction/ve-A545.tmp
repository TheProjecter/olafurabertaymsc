#include "Octree.h"

Octree::Octree(D3DXVECTOR3 position, float halfWidth, int depthLimit)
{
	Position = position;
	HalfWidth = halfWidth;
	DepthLimit = depthLimit;

	ParentNode = BuildOctree(position, halfWidth, depthLimit, true);
	DrawSetUp = false;

	this->sphere = Sphere();
	this->sphere.init(1.0f, 5, 5);
}

OctreeNode* Octree::BuildOctree(D3DXVECTOR3 position, float halfWidth, int depthLimit, bool isParent){
	if (depthLimit < 0) 
		return NULL;
	else {
		if(isParent)
			HalfWidth = halfWidth;

		// Construct and fill in root of this subtree
		OctreeNode *pNode = new OctreeNode;
		pNode->center = position;
		pNode->halfWidth = halfWidth;
		pNode->pObjList = NULL;
		// Recursively construct the eight children of the subtree
		D3DXVECTOR3 offset;
		float step = halfWidth * 0.5f;
		for (int i = 0; i < 8; i++) {
			offset.x = ((i & 1) ? step : -step);
			offset.y = ((i & 2) ? step : -step);
			offset.z = ((i & 4) ? step : -step);
			pNode->pChild[i] = BuildOctree(position + offset, step, depthLimit - 1, false);

		}

		return pNode;
	}
}

void Octree::InsertObject(SurfelNode* surfelNode){
	int index = 0, straddle = 0;

	for (int i = 0; i < 3; i++) {
		float delta = surfelNode->surfel.pos[i] - ParentNode->center[i];
		if (abs(delta) > ParentNode->halfWidth + ((surfelNode->surfel.normal[i] == 0.0f) ? surfelNode->surfel.radius : 0.0f)) {
			straddle = 1;
			break;
		}
		if (delta > 0.0f) index |= (1 << i); // ZYX
	}
	if (!straddle && ParentNode->pChild[index]) {
		// Fully contained in existing child node; insert in that subtree
		InsertObject(ParentNode->pChild[index], surfelNode);
	} else {
		// Straddling, or no child node to descend into, so
		// link object into linked list at this node
		surfelNode->nextSurfel = ParentNode->pObjList;
		ParentNode->pObjList = surfelNode;
	}
}

void Octree::InsertObject(OctreeNode *pTree, SurfelNode* surfelNode)
{
	int index = 0, straddle = 0;

	for (int i = 0; i < 3; i++) {
		float delta = surfelNode->surfel.pos[i] - pTree->center[i];
		if (abs(delta) > ParentNode->halfWidth + ((surfelNode->surfel.normal[i] == 0.0f) ? surfelNode->surfel.radius : 0.0f)) {
			straddle = 1;
			break;
		}
		if (delta > 0.0f) index |= (1 << i); // ZYX
	}
	if (!straddle && pTree->pChild[index]) {
		// Fully contained in existing child node; insert in that subtree
		InsertObject(pTree->pChild[index], surfelNode);
	} else {
		// Straddling, or no child node to descend into, so
		// link object into linked list at this node
		surfelNode->nextSurfel = pTree->pObjList;
		pTree->pObjList = surfelNode;
	}
}

void Octree::CleanUpDrawables(){
	if(DrawSetUp){
		effect.CleanUp();
		vertexBuffer->Release();
		vertexBuffer = NULL;
		DrawSetUp = false;	
	}
}

void Octree::CleanUp(){

	CleanUpNode(ParentNode);

	delete ParentNode;
}

void Octree::CleanUpNode(OctreeNode* node){

	if(!node)
		return;

	for(int i = 0; i<8; i++){
		CleanUpNode(node->pChild[i]);
	}

	/*if(node->pObjList){
		SurfelNode *sn = node->pObjList;
		while(node->pObjList != NULL){
			sn = node->pObjList->nextSurfel;
			
			delete node->pObjList;
			node->pObjList = NULL;

			node->pObjList = sn;
		}
	}
	*/
	delete node->pObjList;
	delete node->pChild;

	delete node;
}

void Octree::Draw(){
	if(!DrawSetUp){
		SetUpDraw();
	}

	DrawChild(this->ParentNode);
}

void Octree::DrawSingleNode(OctreeNode *node){
	D3DXMatrixScaling(&tmpScale, node->halfWidth / HalfWidth, node->halfWidth / HalfWidth, node->halfWidth / HalfWidth);
	D3DXMatrixTranslation(&tmpWorld, node->center.x, node->center.y, node->center.z);
	
	effect.SetMatrix("World", tmpScale * tmpWorld);
	effect.SetMatrix("View", Helpers::Globals::AppCamera.View());
	effect.SetMatrix("Projection", Helpers::Globals::AppCamera.Projection());

	effect.PreDraw();

	UINT stride = sizeof( Structs::SIMPLE_VERTEX);
	UINT offset = 0;

	Helpers::Globals::Device->IASetPrimitiveTopology( D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP);
	Helpers::Globals::Device->IASetVertexBuffers( 0, 1, &vertexBuffer, &stride, &offset );
	Helpers::Globals::Device->IASetIndexBuffer( indexBuffer, DXGI_FORMAT_R32_UINT, 0 );

	effect.Draw(8);

	sphereEffect.SetMatrix("View", Helpers::Globals::AppCamera.View());
	sphereEffect.SetMatrix("Projection", Helpers::Globals::AppCamera.Projection());
	sphereEffect.SetFloatVector("CameraPos", Helpers::Globals::AppCamera.Position());
	sphereEffect.PreDraw();

	sphereEffect.SetMatrix("World", tmpScale * tmpWorld);
	sphere.Draw(&sphereEffect);
}

void Octree::DrawChild(OctreeNode *node){
	if(!node)
		return;

	if(node->pObjList){
		DrawSingleNode(node);
	}

	if(node->pChild){
		for(int i = 0; i<8; i++){
			DrawChild(node->pChild[i]);
		}
	}
}

void Octree::SetUpDraw(){

	D3D10_INPUT_ELEMENT_DESC layout[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0 }, // pos
	};
	
	effect = Helpers::CustomEffect("Simple.fx", "SimpleTechnique", CUSTOM_EFFECT_TYPE_PIXEL | CUSTOM_EFFECT_TYPE_VERTEX, layout, 1);
	effect.AddVariable("World");
	effect.AddVariable("View");
	effect.AddVariable("Projection");

	// box code taken from Beginning Directx 9 by Wendy Jones
	Structs::SIMPLE_VERTEX vertices[8];

	vertices[0].pos = D3DXVECTOR3(-HalfWidth, -HalfWidth, -HalfWidth);
	vertices[1].pos = D3DXVECTOR3(-HalfWidth, -HalfWidth, HalfWidth);
	vertices[2].pos = D3DXVECTOR3(HalfWidth, -HalfWidth, HalfWidth);
	vertices[3].pos = D3DXVECTOR3(HalfWidth, -HalfWidth, -HalfWidth);

	vertices[4].pos = D3DXVECTOR3(-HalfWidth, HalfWidth, -HalfWidth);
	vertices[5].pos = D3DXVECTOR3(-HalfWidth, HalfWidth, HalfWidth);
	vertices[6].pos = D3DXVECTOR3(HalfWidth, HalfWidth, HalfWidth);
	vertices[7].pos = D3DXVECTOR3(HalfWidth, HalfWidth, -HalfWidth);

	D3D10_BUFFER_DESC bd;
	bd.Usage = D3D10_USAGE_DEFAULT;
	bd.ByteWidth = 8 * sizeof( Structs::SIMPLE_VERTEX);
	bd.BindFlags = D3D10_BIND_VERTEX_BUFFER;
	bd.CPUAccessFlags = 0;
	bd.MiscFlags = 0;
	D3D10_SUBRESOURCE_DATA InitData;
	InitData.pSysMem = vertices;

	HR(Helpers::Globals::Device->CreateBuffer( &bd, &InitData, &vertexBuffer));	

	// Create indices
	unsigned int indices[] = { 
		0, 1, 
		/*1, 2,
		2, 3, 
		3, 0, 
		0, 4,
		4, 5, 
		5, 6, 
		6, 7, 
		7, 4, 	*/

	};

	D3D10_BUFFER_DESC bufferDesc;
	bufferDesc.Usage           = D3D10_USAGE_DEFAULT;
	bufferDesc.ByteWidth       = sizeof( indices );
	bufferDesc.BindFlags       = D3D10_BIND_INDEX_BUFFER;
	bufferDesc.CPUAccessFlags  = 0;
	bufferDesc.MiscFlags       = 0;

	D3D10_SUBRESOURCE_DATA indexInitData;
	indexInitData.pSysMem = indices;
	indexInitData.SysMemPitch = 0;
	indexInitData.SysMemSlicePitch = 0;
	HR(Helpers::Globals::Device->CreateBuffer( &bufferDesc, &indexInitData, &indexBuffer ));

	DrawSetUp = true;

	D3D10_INPUT_ELEMENT_DESC sphereLayout[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0 }, // pos
		{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, sizeof(D3DXVECTOR3), D3D10_INPUT_PER_VERTEX_DATA, 0 }, // normal
		{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 2*sizeof(D3DXVECTOR3), D3D10_INPUT_PER_VERTEX_DATA, 0 }, // dimensions
	};

	this->SetMaterialInfo(0.600672f, 0.668533f);

	sphereEffect = Helpers::CustomEffect("SphereEffect.fx", "SphereTechnique", CUSTOM_EFFECT_TYPE_PIXEL | CUSTOM_EFFECT_TYPE_VERTEX, sphereLayout, 3);
	sphereEffect.AddVariable("World");
	sphereEffect.AddVariable("View");
	sphereEffect.AddVariable("Projection");
	// image taken from http://www.cgtextures.com/getfile.php/ConcreteRough0019_2_S.jpg?id=38615&s=s&PHPSESSID=fb96f672ea0d7aff54fd54fe3f539e00
	sphereEffect.AddTexture("tex", "Textures\\Projectile.jpg");

	sphereEffect.AddVariable("LightPos");
	sphereEffect.AddVariable("AmbientColor");
	sphereEffect.AddVariable("CameraPos");
	sphereEffect.AddVariable("LightDirection");
	sphereEffect.AddVariable("A");
	sphereEffect.AddVariable("B");
	sphereEffect.AddVariable("rhoOverPi");
	sphereEffect.AddVariable("LightColor");		

	sphereEffect.SetFloatVector("AmbientColor", Helpers::Globals::AppLight.GetAmbientColor());
	sphereEffect.SetFloatVector("LightPos", Helpers::Globals::AppLight.GetPosition());
	sphereEffect.SetFloatVector("LightDirection", Helpers::Globals::AppLight.GetDirection());
	sphereEffect.SetFloat("A", this->A);
	sphereEffect.SetFloat("B", this->B);
	sphereEffect.SetFloat("rhoOverPi", this->rhoOverPi);
	sphereEffect.SetFloatVector("LightColor", Helpers::Globals::AppLight.GetColor());

	// image taken from http://www.cgtextures.com/getfile.php/ConcreteRough0019_2_S.jpg?id=38615&s=s&PHPSESSID=fb96f672ea0d7aff54fd54fe3f539e00
	sphereEffect.SetTexture("tex", "Textures\\Projectile.jpg");
}